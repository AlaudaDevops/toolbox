/*
Copyright 2025 The AlaudaDevops Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package updater provides language-agnostic vulnerability package updating functionality.
package updater

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/sirupsen/logrus"
)

// CommandOutputHeader is the header template for generated command output files
const CommandOutputHeader = `#!/bin/sh
# This file is automatically generated by dependabot, please do not modify it manually!!!
`

// BaseUpdater provides common functionality for language-specific updaters
type BaseUpdater struct {
	// projectPath is the path to the project
	projectPath string
	// commandOutputFile is the file path to output successful commands
	commandOutputFile string
}

// NewBaseUpdater creates a new base updater with common functionality
func NewBaseUpdater(projectPath string, commandOutputFile string) *BaseUpdater {
	updater := &BaseUpdater{
		projectPath:       projectPath,
		commandOutputFile: commandOutputFile,
	}

	// Initialize the output file if specified
	if commandOutputFile != "" {
		if err := updater.initializeOutputFile(); err != nil {
			logrus.Errorf("failed to initialize output file: %v", err)
		}
	}

	return updater
}

// initializeOutputFile creates or recreates the output file with header
func (b *BaseUpdater) initializeOutputFile() error {
	outputFilePath := filepath.Join(b.projectPath, b.commandOutputFile)

	// Create output directory if it doesn't exist
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Create or truncate the file
	file, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer file.Close()

	// Write header to file
	if _, err := file.WriteString(CommandOutputHeader); err != nil {
		return fmt.Errorf("failed to write header to output file: %w", err)
	}

	// Set executable permissions for the shell script
	if err := os.Chmod(outputFilePath, 0755); err != nil {
		return fmt.Errorf("failed to set executable permissions: %w", err)
	}

	logrus.Debugf("Initialized output file with header: %s", outputFilePath)
	return nil
}

// LogSuccessfulCommand logs the successful command to the configured output file
func (b *BaseUpdater) LogSuccessfulCommand(command string) error {
	if b.commandOutputFile == "" {
		return nil
	}

	if err := b.appendToFile(command + "\n"); err != nil {
		return err
	}

	logrus.Debugf("Logged successful command [%s] to: %s", command, filepath.Join(b.projectPath, b.commandOutputFile))
	return nil
}

// LogComment logs a comment line to the output file
func (b *BaseUpdater) LogComment(comment string) error {
	if b.commandOutputFile == "" {
		return nil
	}

	// Ensure comment starts with #
	if len(comment) == 0 || comment[0] != '#' {
		comment = "# " + comment
	}

	return b.appendToFile(comment + "\n")
}

// LogFailedCommand logs a failed command as a comment with error details
func (b *BaseUpdater) LogFailedCommand(command string, err error) error {
	if b.commandOutputFile == "" {
		return nil
	}

	failureLog := fmt.Sprintf("# FAILED: %s\n# Error: %v\n", command, err)
	return b.appendToFile(failureLog)
}

// LogBlankLine adds a blank line to the output file for readability
func (b *BaseUpdater) LogBlankLine() error {
	if b.commandOutputFile == "" {
		return nil
	}

	return b.appendToFile("\n")
}

// appendToFile is a helper to append content to the output file
func (b *BaseUpdater) appendToFile(content string) error {
	outputFilePath := filepath.Join(b.projectPath, b.commandOutputFile)

	// Create output directory if it doesn't exist
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Open file in append mode
	file, err := os.OpenFile(outputFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("failed to open output file: %w", err)
	}
	defer file.Close()

	// Write to file
	if _, err := file.WriteString(content); err != nil {
		return fmt.Errorf("failed to write to output file: %w", err)
	}

	return nil
}
